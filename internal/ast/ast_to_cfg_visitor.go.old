package ast

import (
	"fmt"
)

type ASTtoCFGVisitor struct {
	ast       *Node // Interface ou struct pour ton AST
	cfg       *CFG
	iNextNode int
}

func NewASTtoCFGVisitor() *ASTtoCFGVisitor {
	return &ASTtoCFGVisitor{
		cfg: NewCFG(),
	}
}

// Génère un nouvel ID de nœud
func (v *ASTtoCFGVisitor) getNewNode() int {
	v.iNextNode++
	return v.iNextNode
}

func (v *ASTtoCFGVisitor) Visit(ast *AST) *CFG {
	v.ast = ast
	v.cfg = NewCFG()
	fmt.Printf("Visiting AST from file: %s\n", v.ast.GetFilename())
	v.visitRoot()
	return v.cfg
}

func (v *ASTtoCFGVisitor) visitRoot() {
	ctx := map[string]int{}
	entryNodeId := v.getNewNode()
	stopNodeId := v.getNewNode()
	rootAST := v.ast.GetRoot()

	v.cfg.SetRoot(entryNodeId)
	v.cfg.SetType(entryNodeId, "Entry")
	v.cfg.SetImage(entryNodeId, "main")
	v.cfg.SetType(stopNodeId, "Exit")

	ctx["parent"] = entryNodeId
	ctx["scope"] = entryNodeId
	ctx["stopId"] = stopNodeId

	if v.ast.GetType(rootAST) == "Start" {
		v.cfg.SetNodePtr(rootAST, entryNodeId)
	}

	v.visitNode(rootAST, ctx)
	v.cfg.AddEdge(ctx["endId"], stopNodeId)
}

func (v *ASTtoCFGVisitor) visitGeneric(astNodeId int, ctx map[string]int) int {
	cfgNode := v.getNewNode()
	v.cfg.SetNodePtr(astNodeId, cfgNode)
	v.cfg.SetType(cfgNode, v.ast.GetType(astNodeId))
	v.cfg.SetImage(cfgNode, v.ast.GetImage(astNodeId))
	v.cfg.AddEdge(ctx["parent"], cfgNode)

	ctx["endId"] = cfgNode
	newCtx := copyContext(ctx)
	newCtx["parent"] = cfgNode

	for _, childId := range v.ast.GetChildren(astNodeId) {
		v.visitNode(childId, newCtx)
		newCtx["parent"] = newCtx["endId"]
	}
	ctx["endId"] = newCtx["endId"]

	return cfgNode
}

func (v *ASTtoCFGVisitor) visitGenericBlock(astNodeId int, ctx map[string]int) {
	newCtx := copyContext(ctx)
	for _, childId := range v.ast.GetChildren(astNodeId) {
		v.visitNode(childId, newCtx)
		newCtx["parent"] = newCtx["endId"]
	}
	ctx["endId"] = newCtx["endId"]
}

func (v *ASTtoCFGVisitor) visitBinOp(astNodeId int, ctx map[string]int) int {
	cfgNode := v.getNewNode()
	v.cfg.SetNodePtr(astNodeId, cfgNode)
	v.cfg.SetType(cfgNode, v.ast.GetType(astNodeId))
	v.cfg.SetImage(cfgNode, v.ast.GetImage(astNodeId))

	newCtx := copyContext(ctx)
	v.visitNode(v.ast.GetChildren(astNodeId)[1], newCtx)
	right := newCtx["endId"]

	newCtx = copyContext(ctx)
	newCtx["parent"] = right
	v.visitNode(v.ast.GetChildren(astNodeId)[0], newCtx)
	left := newCtx["endId"]

	v.cfg.AddEdge(left, cfgNode)
	ctx["endId"] = cfgNode

	return cfgNode
}

func (v *ASTtoCFGVisitor) visitNode(astNodeId int, ctx map[string]int) {
	curType := v.ast.GetType(astNodeId)
	if curType == "" {
		panic("ASTException: Missing type in a node")
	}

	switch curType {
	case "BinOP", "RelOP", "LogicOP":
		v.visitBinOp(astNodeId, ctx)
	case "Block", "Start":
		v.visitGenericBlock(astNodeId, ctx)
	case "PLACEHOLDER":
		v.visitPassthrough(astNodeId, ctx)
	default:
		v.visitGeneric(astNodeId, ctx)
	}
}

func (v *ASTtoCFGVisitor) visitPassthrough(astNodeId int, ctx map[string]int) {
	for _, childId := range v.ast.GetChildren(astNodeId) {
		v.visitNode(childId, ctx)
	}
}

// Helper function to copy a context map
func copyContext(ctx map[string]int) map[string]int {
	newCtx := make(map[string]int)
	for k, v := range ctx {
		newCtx[k] = v
	}
	return newCtx
}
