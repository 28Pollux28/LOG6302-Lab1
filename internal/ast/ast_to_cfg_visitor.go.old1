package ast

import "fmt"

type VisitorCFGBuilder struct {
	CFG      *CFG
	prevNode *CFGNode
}

// Initialise un visiteur pour construire le CFG
func NewVisitorCFGBuilder() *VisitorCFGBuilder {
	return &VisitorCFGBuilder{
		CFG:      NewCFG(),
		prevNode: nil,
	}
}

// Visite chaque nœud de l'arbre et construit le CFG
func (v *VisitorCFGBuilder) VisitNode(n *Node) {
	var currentNode *CFGNode

	switch n.Kind {
	case "if_statement":
		// Crée un nœud conditionnel pour l'instruction if
		currentNode = v.CFG.AddNode("Condition: if")
		if v.prevNode != nil {
			v.CFG.AddEdge(v.prevNode, currentNode, "normal")
		}

		// Trouve les descendants (then & else)
		if len(n.Descendants) > 0 {
			thenBlock := n.Descendants[0]
			thenNode := v.CFG.AddNode("Then Block")
			v.CFG.AddEdge(currentNode, thenNode, "condition_true")

			thenBlock.WalkPostfix(v)

			if len(n.Descendants) > 1 {
				elseBlock := n.Descendants[1]
				elseNode := v.CFG.AddNode("Else Block")
				v.CFG.AddEdge(currentNode, elseNode, "condition_false")

				elseBlock.WalkPostfix(v)
			}
		}
	case "while_statement":
		currentNode = v.CFG.AddNode("Condition: while")
		if v.prevNode != nil {
			v.CFG.AddEdge(v.prevNode, currentNode, "normal")
		}

		if len(n.Descendants) > 0 {
			bodyBlock := n.Descendants[0]
			bodyNode := v.CFG.AddNode("While Body")
			v.CFG.AddEdge(currentNode, bodyNode, "loop_body")

			bodyBlock.WalkPostfix(v)
			// Boucle arrière vers la condition
			v.CFG.AddEdge(bodyNode, currentNode, "loop_back")
		}

	default:
		// Cas général pour les instructions simples
		currentNode = v.CFG.AddNode(fmt.Sprintf("Node: %s", n.Kind))
		if v.prevNode != nil {
			v.CFG.AddEdge(v.prevNode, currentNode, "normal")
		}
	}

	// Met à jour le dernier nœud visité
	v.prevNode = currentNode
}
